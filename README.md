# go_Sort
go语言的基础排序算法和二叉查找树


# 快速排序算法

是对插入算法的一种优化，利用对问题的二分化，实现递归完成快速排序，在所有算法中二分化是最常用的方式，将问题尽量的分成两种情况加以分析，最终以形成类似树的方式加以利用，因为在比较模型中的算法中，最快的排序时间负载度为 O(nlgn).

```步骤```：

将数据根据一个值按照大小分成左右两边，左边小于此值，右边大于

将两边数据进行递归调用步骤1

将所有数据合并


# 堆排序算法
首先建一个堆，然后调整堆，调整过程是将节点和子节点进行比较，将其中最大的值变为父节点，递归调整调整次数lgn,最后将根节点和尾节点交换再n次调整O(nlgn).

```步骤```：

创建最大堆或者最小堆（我是最小堆）

调整堆

交换首尾节点(为了维持一个完全二叉树才要进行收尾交换)


# 冒泡排序算法

没啥可说的，循环

# 二分查找方法

在一组有序数组中，将数组一分为二，将要查询的元素和分割点进行比较，分为三种情况


```步骤```：
相等直接返回

元素大于分割点，在分割点右侧继续查找

元素小于分割点，在分割点左侧继续查找


# 选择排序

从未排序数据中选择最大或者最小的值和当前值交换 O(n^2).

```步骤```：

选择一个数当最小值或者最大值，进行比较然后交换

循环向后查进行

# 基数排序算法

基数排序类似计数排序，需要额外的空间来记录对应的基数内的数据 额外的空间是有序的，最终时间复杂度O(nlogrm),r是基数，r^m=n.当给定 特定的范围，计数排序又可以叫桶排序，当以10进制为基数时就是简单的桶排序

```步骤```：

从个位开始排序，从低到高进行递推
比较过程中如果遇到高位相同时，顺序不变

# 拓扑排序

编译有序依赖的文件

```两种算法```

Kahn算法:利用贪心算法，如果两个顶点，顶点b依赖于顶点a,就将a指向b,当一个顶点的入度为零，将这个顶点就是最优排序点， 并且将顶点从图中移除，将可达顶点的入度减一。

DFS算法：使用深度算法，产生逆向邻接表先输出其他依赖，最后输出自己。


# 插入排序算法

插入算法，从第一个数开始进行循环，插入到一个已经排序的数组中循环遍历所有元素，最终返回所有元素的排好的序列时间复杂度为 O(n^2).

```步骤```：

选择一个数进行比较然后将比这个值小的元素插入这个值之前

循环向后查进行

# 字符串匹配：

```三种算法：```

BF(Brute force)算法：每次向后移动一位进行匹配

RK(Rabin-Karp)算法：实现：将每组要匹配长度的字符串进行hash，再hash后的元素里找

BM(Boyer-Moore)算法：坏前缀：普通匹配只一位一位移动，移动规则为 si(坏字符的位置) xi(坏字符在匹配字符最后出现的位置) 都没有xi=-1 移动距离等于si-xi
好后缀：坏前缀有可能产生负数，所以还要利用好后缀来进行匹配，好后缀类似坏前缀如果匹配串中有和好后缀相同的子串 ，移动到最靠后的子串的位置，如果没有相同的子串，就需要在匹配的子串中，查找和前缀子串匹配最长的子串进行移动。


